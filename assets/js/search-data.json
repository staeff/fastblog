{
  
    
        "post0": {
            "title": "Dive into XML",
            "content": "The ElementTree library is part of the Python standard library . import xml.etree.ElementTree as etree . The primary entry point for the ElementTree library is the parse() function, which can take a filename or a file-like object. This function parses the entire document at once. If memory is tight, there are ways to parse an XML document incrementally instead. . tree = etree.parse(&#39;feed.xml&#39;) . The parse() function returns an object which represents the entire document. This is not the root element. To get a reference to the root element, call the getroot() method. . root = tree.getroot() . In the example file feed.xml the root element is the feed element in the http://www.w3.org/2005/Atom namespace. The string representation of this object reinforces an important point: an XML element is a combination of its namespace and its tag name (also called the local name). Every element in this document is in the Atom namespace, so the root element is represented as {http://www.w3.org/2005/Atom}feed. . root . &lt;Element &#39;{http://www.w3.org/2005/Atom}feed&#39; at 0x10b8e7db0&gt; . ElementTree represents XML elements as {namespace}localname. You’ll see and use this format in multiple places in the ElementTree API. . root.tag . &#39;{http://www.w3.org/2005/Atom}feed&#39; . The “length” of the root element is the number of child elements. . len(root) . 8 . An element can be used as an iterator to loop through all of its child elements. The list of child elements only includes direct children. . for child in root: print(child) . &lt;Element &#39;{http://www.w3.org/2005/Atom}title&#39; at 0x10b8e7e50&gt; &lt;Element &#39;{http://www.w3.org/2005/Atom}subtitle&#39; at 0x10b8e7ef0&gt; &lt;Element &#39;{http://www.w3.org/2005/Atom}id&#39; at 0x10b8ed040&gt; &lt;Element &#39;{http://www.w3.org/2005/Atom}updated&#39; at 0x10b8ed0e0&gt; &lt;Element &#39;{http://www.w3.org/2005/Atom}link&#39; at 0x10b8ed220&gt; &lt;Element &#39;{http://www.w3.org/2005/Atom}entry&#39; at 0x10b8ed2c0&gt; &lt;Element &#39;{http://www.w3.org/2005/Atom}entry&#39; at 0x10b8eda90&gt; &lt;Element &#39;{http://www.w3.org/2005/Atom}entry&#39; at 0x10b8edf90&gt; . Attributes Are Dictonaries . Once you have a reference to a specific element, you can easily get its attributes as a Python dictionary. . root.attrib . {&#39;{http://www.w3.org/XML/1998/namespace}lang&#39;: &#39;en&#39;} . root[4] . &lt;Element &#39;{http://www.w3.org/2005/Atom}link&#39; at 0x10b8ed220&gt; . root[4].attrib . {&#39;rel&#39;: &#39;alternate&#39;, &#39;type&#39;: &#39;text/html&#39;, &#39;href&#39;: &#39;http://diveintomark.org/&#39;} . root[3] . &lt;Element &#39;{http://www.w3.org/2005/Atom}updated&#39; at 0x10b8ed0e0&gt; . # so its .attrib is just an empty dictionary. root[3].attrib . {} . Searching For Nodes Within An XML Document . findall() . Each element — including the root element, but also child elements — has a findall() method. It finds all matching elements among the element’s children. . tree . &lt;xml.etree.ElementTree.ElementTree at 0x10b8eb0a0&gt; . namespace = &#39;{http://www.w3.org/2005/Atom}&#39; . root.findall(f&#39;{namespace}entry&#39;) . [&lt;Element &#39;{http://www.w3.org/2005/Atom}entry&#39; at 0x10b8ed2c0&gt;, &lt;Element &#39;{http://www.w3.org/2005/Atom}entry&#39; at 0x10b8eda90&gt;, &lt;Element &#39;{http://www.w3.org/2005/Atom}entry&#39; at 0x10b8edf90&gt;] . root.tag . &#39;{http://www.w3.org/2005/Atom}feed&#39; . # element &#39;feed&#39; does not have any child element &#39;feed&#39; root.findall(f&#39;{namespace}feed&#39;) . [] . # therefore this query returns an empty list root.findall(f&#39;{namespace}author&#39;) . [] . For convenience, the tree object (returned from the etree.parse() function) has several methods that mirror the methods on the root element. The results are the same as if you had called the tree.getroot().findall() method. . tree.findall(f&#39;{namespace}entry&#39;) . [&lt;Element &#39;{http://www.w3.org/2005/Atom}entry&#39; at 0x10b8ed2c0&gt;, &lt;Element &#39;{http://www.w3.org/2005/Atom}entry&#39; at 0x10b8eda90&gt;, &lt;Element &#39;{http://www.w3.org/2005/Atom}entry&#39; at 0x10b8edf90&gt;] . tree.findall(f&#39;{namespace}author&#39;) . [] . find() . The find() method takes an ElementTree query returns the first matching element. This is useful for situations where you are only expecting one match, or if there are multiple matches, you only care about the first one. . entries = tree.findall(f&#39;{namespace}entry&#39;) len(entries) . 3 . title_element = entries[0].find(f&#39;{namespace}title&#39;) title_element.text . &#39;Dive into history, 2009 edition&#39; . There are no elements in this entry named foo, so this returns None. . foo_element = entries[0].find(f&#39;{namespace}foo&#39;) foo_element . type(foo_element) . NoneType . Beware: In a boolean context, ElementTree element objects will evaluate to False if they contain no children (i.e. if len(element) is 0). This means that if element.find(&#39;...&#39;) is not testing whether the find() method found a matching element; it’s testing whether that matching element has any child elements! To test whether the find() method returned an element, use if element.find(&#39;...&#39;) is not None. . Search for descendant elements . A query like //{http://www.w3.org/2005/Atom}link with the two slashes at the beginning finds any elements, regardless of nesting level. . all_links = tree.findall(f&#39;.//{namespace}link&#39;) all_links . [&lt;Element &#39;{http://www.w3.org/2005/Atom}link&#39; at 0x10b8ed220&gt;, &lt;Element &#39;{http://www.w3.org/2005/Atom}link&#39; at 0x10b8ed590&gt;, &lt;Element &#39;{http://www.w3.org/2005/Atom}link&#39; at 0x10b8edcc0&gt;, &lt;Element &#39;{http://www.w3.org/2005/Atom}link&#39; at 0x10b8ef130&gt;] . all_links[0].attrib . {&#39;rel&#39;: &#39;alternate&#39;, &#39;type&#39;: &#39;text/html&#39;, &#39;href&#39;: &#39;http://diveintomark.org/&#39;} . all_links[1].attrib . {&#39;rel&#39;: &#39;alternate&#39;, &#39;type&#39;: &#39;text/html&#39;, &#39;href&#39;: &#39;http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition&#39;} . all_links[2].attrib . {&#39;rel&#39;: &#39;alternate&#39;, &#39;type&#39;: &#39;text/html&#39;, &#39;href&#39;: &#39;http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress&#39;} . all_links[3].attrib . {&#39;rel&#39;: &#39;alternate&#39;, &#39;type&#39;: &#39;text/html&#39;, &#39;href&#39;: &#39;http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats&#39;} . ElementTree’s findall() method is a very powerful feature, but the query language can be a bit surprising. ElementTree’s query language is similar enough to XPath to do basic searching, but dissimilar enough that it may annoy you if you already know XPath. . Parsing with lxml . lxml utilizes the popular libxml2 parser. It provides a 100% compatible ElementTree API, then extends it with full XPath 1.0 support and a few other niceties. . namespace = &#39;{http://www.w3.org/2005/Atom}&#39; . from lxml import etree tree = etree.parse(&#39;feed.xml&#39;) root = tree.getroot() root.findall(f&#39;{namespace}entry&#39;) . [&lt;Element {http://www.w3.org/2005/Atom}entry at 0x10bf9ab80&gt;, &lt;Element {http://www.w3.org/2005/Atom}entry at 0x10bf9abc0&gt;, &lt;Element {http://www.w3.org/2005/Atom}entry at 0x10bf9ac00&gt;] . For large XML documents lxml is significantly faster than the built-in ElementTree library. If you’re only using the ElementTree API and want to use the fastest available implementation, you can try to import lxml and fall back to the built-in ElementTree. . try: from lxml import etree except ImportError: import xml.etree.ElementTree as etree . The following query finds all elements in the Atom namespace, anywhere in the document, that have an href attribute. The // at the beginning of the query means “elements anywhere (not just as children of the root element).” {http://www.w3.org/2005/Atom} means “only elements in the Atom namespace.” * means “elements with any local name.” And [@href] means “has an href attribute.” . tree.findall(f&#39;//{namespace}*[@href]&#39;) . [&lt;Element {http://www.w3.org/2005/Atom}link at 0x10bfa6280&gt;, &lt;Element {http://www.w3.org/2005/Atom}link at 0x10bfa62c0&gt;, &lt;Element {http://www.w3.org/2005/Atom}link at 0x10bfa6300&gt;, &lt;Element {http://www.w3.org/2005/Atom}link at 0x10bfa6340&gt;] . tree.findall(f&quot;//{namespace}*[@href=&#39;http://diveintomark.org/&#39;]&quot;) . [&lt;Element {http://www.w3.org/2005/Atom}link at 0x10bfa6280&gt;] . NS = &#39;{http://www.w3.org/2005/Atom}&#39; . The following query searches for Atom author elements that have an Atom uri element as a child. This only returns two author elements, the ones in the first and second entry. The author in the last entry contains only a name, not a uri. . tree.findall(f&#39;//{NS}author[{NS}uri]&#39;) . [&lt;Element {http://www.w3.org/2005/Atom}author at 0x10bfa6600&gt;, &lt;Element {http://www.w3.org/2005/Atom}author at 0x10bfa6840&gt;] . XPath support in lxml . Technically an XPath expressions returns a list of nodes. (Thats what the DOM of a parsed XML document is made up of). Depending on their type, nodes can be elements, attributes, or even text content. . To perform XPath queries on namespaced elements, you need to define a namespace prefix mapping. This is just a Python dictionary. . NSMAP = {&#39;atom&#39;: &#39;http://www.w3.org/2005/Atom&#39;} . The XPath expression searches for category elements (in the Atom namespace) that contain a term attribute with the value accessibility. The /.. bit means to return the parent element of the category element you just found. So this single XPath query will find all entries with a child element of &lt;category term=&#39;accessibility&#39;&gt;. In this case the xpath() function returns a list of ElementTree objects. . entries = tree.xpath(&quot;//atom:category[@term=&#39;accessibility&#39;]/..&quot;, namespaces=NSMAP) entries . [&lt;Element {http://www.w3.org/2005/Atom}entry at 0x10bf9abc0&gt;] . The following query returns a list that contains a string. It selects text content (text()) of the title element (atom:title) that is a child of the current element (./). . entry = entries[0] # It is an ElementTree object and therefore supports entry.xpath(&#39;./atom:title/text()&#39;, namespaces=NSMAP) . [&#39;Accessibility is a harsh mistress&#39;] . Generating XML . You can create XML documents from scratch. . import xml.etree.ElementTree as etree atom_NS = &#39;{http://www.w3.org/2005/Atom}&#39; w3_NS = &#39;{http://www.w3.org/XML/1998/namespace}&#39; . To create a new element, instantiate the Element class. You pass the element name (namespace + local name) as the first argument. This statement creates a feed element in the Atom namespace. This will be our new document’s root element. . To add attributes to the newly created element, pass a dictionary of attribute names and values in the attrib argument. Note that the attribute name should be in the standard ElementTree format, {namespace}localname. . new_feed = etree.Element(f&#39;{atom_NS}feed&#39;, attrib={f&#39;{w3_NS}lang&#39;: &#39;en&#39;}) . At any time, you can serialize any element (and its children) with the ElementTree tostring() function. . print(etree.tostring(new_feed)) . b&#39;&lt;ns0:feed xmlns:ns0=&#34;http://www.w3.org/2005/Atom&#34; xml:lang=&#34;en&#34; /&gt;&#39; . Default namespaces . A default namespace is useful for documents — like Atom feeds — where every element is in the same namespace. The namespace is declared once and each element just needs to be declared with its local name (&lt;feed&gt;, &lt;link&gt;, &lt;entry&gt;). There is no need to use any prefixes unless you want to declare elements from another namespace. . The first snippet has an default, implicit namespace. . &lt;feed xmlns=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;/&gt; . Whereas the second, this is how ElementTree serializes namespaced XML elements, has an explicit namespace. This is technically accurate, but a bit cumbersome to work with. . Both DOMs of the serialisations in the example are identical. . &lt;ns0:feed xmlns:ns0=&#39;http://www.w3.org/2005/Atom&#39; xml:lang=&#39;en&#39;/&gt; . lxml does offer fine-grained control over how namespaced elements are serialized. The built-in ElementTree does not. . # in the example import lxml.etree . Define a namespace mapping as a dictionary. Dictionary values are namespaces; dictionary keys are the desired prefix. Using None as a prefix effectively declares a default namespace. . NSMAP = {None: &#39;http://www.w3.org/2005/Atom&#39;} . Now you can pass the lxml-specific nsmap argument when you create an element, and lxml will respect the namespace prefixes you’ve defined. . new_feed = lxml.etree.Element(&#39;feed&#39;, nsmap=NSMAP) . This serialization defines the Atom namespace as the default namespace and declares the feed element without a namespace prefix. . print(lxml.etree.tounicode(new_feed)) . &lt;feed xmlns=&#34;http://www.w3.org/2005/Atom&#34;/&gt; . # a byte object print(lxml.etree.tostring(new_feed)) . b&#39;&lt;feed xmlns=&#34;http://www.w3.org/2005/Atom&#34;/&gt;&#39; . You can always add attributes to any element with the set() method. It takes two arguments: the attribute name in standard ElementTree format, then the attribute value. This method is not lxml-specific. . new_feed.set(&#39;{http://www.w3.org/XML/1998/namespace}lang&#39;, &#39;en&#39;) print(lxml.etree.tounicode(new_feed)) . &lt;feed xmlns=&#34;http://www.w3.org/2005/Atom&#34; xml:lang=&#34;en&#34;/&gt; . Create child elements . Instantiate the SubElement class to create a child element of an existing element. The only required arguments are the parent element (new_feed in this case) and the new element’s name. Since this child element will inherit the namespace mapping of its parent, there is no need to redeclare the namespace or prefix here. . You can also pass in an attribute dictionary. Keys are attribute names; values are attribute values. . title = lxml.etree.SubElement(new_feed, &#39;title&#39;, attrib={&#39;type&#39;:&#39;html&#39;}) print(lxml.etree.tounicode(new_feed)) . &lt;feed xmlns=&#34;http://www.w3.org/2005/Atom&#34; xml:lang=&#34;en&#34;&gt;&lt;title type=&#34;html&#34;/&gt;&lt;/feed&gt; . Set the .text property to add the text content to an element. . title.text = &#39;dive into &amp;hellip;&#39; print(lxml.etree.tounicode(new_feed)) . &lt;feed xmlns=&#34;http://www.w3.org/2005/Atom&#34; xml:lang=&#34;en&#34;&gt;&lt;title type=&#34;html&#34;&gt;dive into &amp;amp;hellip;&lt;/title&gt;&lt;/feed&gt; . print(lxml.etree.tounicode(new_feed, pretty_print=True)) . &lt;feed xmlns=&#34;http://www.w3.org/2005/Atom&#34; xml:lang=&#34;en&#34;&gt; &lt;title type=&#34;html&#34;&gt;dive into &amp;amp;hellip;&lt;/title&gt; &lt;/feed&gt; . Parsing broken xml . lxml is capable of parsing not wellformed xml documents. . The parser chokes on this document, because because the &amp;hellip; entity is not defined in XML. . import lxml.etree tree = lxml.etree.parse(&#39;broken-feed.xml&#39;) . Traceback (most recent call last): File &#34;/Users/staeff/Projects/python/dive-into-notebooks/.venv/lib/python3.8/site-packages/IPython/core/interactiveshell.py&#34;, line 3444, in run_code exec(code_obj, self.user_global_ns, self.user_ns) File &#34;/var/folders/c4/kd_bd76n4s339m4tdc5dc8qm0000gn/T/ipykernel_72241/3961460450.py&#34;, line 2, in &lt;module&gt; tree = lxml.etree.parse(&#39;broken-feed.xml&#39;) File &#34;src/lxml/etree.pyx&#34;, line 3521, in lxml.etree.parse File &#34;src/lxml/parser.pxi&#34;, line 1859, in lxml.etree._parseDocument File &#34;src/lxml/parser.pxi&#34;, line 1885, in lxml.etree._parseDocumentFromURL File &#34;src/lxml/parser.pxi&#34;, line 1789, in lxml.etree._parseDocFromFile File &#34;src/lxml/parser.pxi&#34;, line 1177, in lxml.etree._BaseParser._parseDocFromFile File &#34;src/lxml/parser.pxi&#34;, line 615, in lxml.etree._ParserContext._handleParseResultDoc File &#34;src/lxml/parser.pxi&#34;, line 725, in lxml.etree._handleParseResult File &#34;src/lxml/parser.pxi&#34;, line 654, in lxml.etree._raiseParseError File &#34;broken-feed.xml&#34;, line 3 &lt;title&gt;dive into &amp;hellip;&lt;/title&gt; ^ XMLSyntaxError: Entity &#39;hellip&#39; not defined, line 3, column 28 . Instantiate the lxml.etree.XMLParser class to create a custom parser. It can take a number of different named arguments. Here we are using the recover argument, so that the XML parser will try its best to “recover” from wellformedness errors. . parser = lxml.etree.XMLParser(recover=True) . This works! The second argument of parse() is the custom parser. . tree = lxml.etree.parse(&#39;broken-feed.xml&#39;, parser) . The parser keeps a log of the wellformedness errors that it has encountered. . parser.error_log . broken-feed.xml:3:28:FATAL:PARSER:ERR_UNDECLARED_ENTITY: Entity &#39;hellip&#39; not defined . tree.findall(&#39;{http://www.w3.org/2005/Atom}title&#39;) . [&lt;Element {http://www.w3.org/2005/Atom}title at 0x10e022d80&gt;] . The parser just dropped the undefined &amp;hellip; entity. The text content of the title element becomes &#39;dive into &#39;. . title = tree.findall(&#39;{http://www.w3.org/2005/Atom}title&#39;)[0] title.text . &#39;dive into &#39; . As you can see from the serialization, the &hellip; entity didn’t get moved; it was simply dropped. . print(lxml.etree.tounicode(tree.getroot())) . &lt;feed xmlns=&#34;http://www.w3.org/2005/Atom&#34; xml:lang=&#34;en&#34;&gt; &lt;title&gt;dive into &lt;/title&gt; &lt;/feed&gt; .",
            "url": "https://staeff.github.io/fastblog/2021/10/11/dive_into_xml.html",
            "relUrl": "/2021/10/11/dive_into_xml.html",
            "date": " • Oct 11, 2021"
        }
        
    
  

  
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://staeff.github.io/fastblog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}